Задание 2.

2.1.
abstract class LinkedList<T>

public const int HEAD_OK = 1; // последняя head() отработала нормально
public const int HEAD_ERR = 2; // список пуст

public const int TAIl_OK = 1; // последняя tail() отработала нормально
public const int TAIl_ERR = 2; // список пуст

public const int RIGHT_OK = 1; // последняя right() отработала нормально
public const int RIGHT_ERR = 2; // список пуст

public const int LEFT_OK = 1; // последняя left() отработала нормально
public const int LEFT_ERR = 2; // список пуст

public const int PUT_RIGHT_OK = 1; // последняя PUT_RIGHT() отработала нормально
public const int PUT_RIGHT_ERR = 2; // список пуст

public const int PUT_LEFT_OK = 1; // последняя PUT_LEFT() отработала нормально
public const int PUT_LEFT_ERR = 2; // список пуст

public const int REMOVE_OK = 1; // последняя remove() отработала нормально
public const int REMOVE_ERR = 2; // список пуст

public const int CLEAR_OK = 1; // последняя clear() отработала нормально
public const int CLEAR_ERR = 2; // список пуст

public const int ADD_TO_EMPTY_OK = 1; // последняя ADD_TO_EMPTY() отработала нормально
public const int ADD_TO_EMPTY_ERR = 2; // список пуст

public const int ADD_TAIL_OK = 1; // последняя ADD_TAIL_NIL() отработала нормально
public const int ADD_TAIL_ERR = 2; // список пуст

public const int IS_VALUE_OK = 1; // последняя IS_VALUE() отработала нормально
public const int IS_VALUE_ERR = 2; // список пуст

public const int REPLACE_OK = 1; // последняя REPLACE() отработала нормально
public const int REPLACE_ERR = 2; // список пуст

public const int FIND_OK = 1; // последняя FIND() отработала нормально
public const int FIND_ERR = 2; // список пуст

public const int REMOVE_ALL_OK = 1; // последняя REMOVE_ALL() отработала нормально
public const int REMOVE_ALL_ERR = 2; // список пуст

// конструктор
// постусловие: создан новый пустой связный список
public LinkedList<T> LinkedList();

public const int cursorsIndex = 0;

// команды (обязательны постусловие):

первый и последний элемент может быть одним и тем же?
// предусловие: в списке хотя-бы один элемент
// предусловие: курсор не первом первом элементе (тогда пропустить операцию?)
// постусловие: курсор на первом узеле в списке
public void head();

// предусловие: в списке хотя-бы один элемент
// предусловие: курсор не последнем элементе (тогда пропустить операцию?)
// постусловие: курсор на последний узеле в списке
public void tail();

// предусловие: не один элемент в списке
// предусловие: курсор не на последнем элементе
// постусловие: сдвинуть курсор на один узел вправо;
public void right();

// предусловие: хотя бы один элент в списке
// постусловие: вставить следом за текущим узлом новый узел с заданным значением
public void put_right(значение);

// предусловие: хотя бы один элент в списке
// постусловие: вставить перед текущим узлом новый узел с заданным значением;
public void put_left(значение);

// предусловие: хотя бы один элемент
// постусловие: удалить текущий узел
public void remove();

// предусловие: хотя бы один элемент
// постусловие: очистить список, cursorsIndex == 0
public void clear();

// предусловие: ни одного элемента в списке
// постусловие: добавить новый элемент
public void add_to_empty(значение);

или пусто тоже норм?
// предусловие: хотя бы один элемент
// постусловие: добавить новый узел в хвост списка
public void add_tail(значение);

// предусловие: хотя бы один элемент
// постусловие: заменить значение текущего узла на заданное
public void replace(значение);

// предусловие: хотя бы один элемент
// постусловие: заменить значение текущего узла на заданное
// постусловие: установить курсор на следующий узел с искомым значением (по отношению к текущему узлу);
public void find(значение);

// предусловие: хотя бы один элемент
// постусловие: удалить в списке все узлы с заданным значением;
public remove_all(значение);

// запросы: (требуют предусловия)

// предусловие: хотя бы один элемент
// постусловие: находится ли курсор в начале списка?
public is_head();

// предусловие: хотя бы один элемент
// постусловие: находится ли курсор в конце списка?;
public is_tail();

// предусловие: хотя бы один элемент
// постусловие: установлен ли курсор на какой-либо узел в списке (по сути, непустой ли список).
public is_value();

// предусловие: должен быть создан список
// постусловие: получить количество узлов в списке
public void size();

// предусловие: хотя бы один элемент
// постусловие: получить значение текущего узла;
public void get();

public int get_head_status(); // возвращает значение HEAD*
public int get_tail_status(); // возвращает значение TAIL_*
public int get_right_status(); // возвращает значение RIGHT_*
public int get_get_status(); // возвращает значение GET_*
...остальные

2.2. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?
Получается, что если сводима -- то это не эффективно. Но почему? Не понимаю :(
Операция атомарна, проще ее включать отдельно.

2.3. Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?
Потому что мы можем скобинировать другие операции?
можно повторить find() несколько раз?

2) Запросы -- 
методы, которые вычисляют некоторое значение на основе своих аргументов 
(и возможно, на основе значений каких-то скрытых атрибутов класса), 
но не меняют значения никаких атрибутов класса (не меняют состояние класса). 
По сути, это чистые функции, которым требуются предусловия.

3) Команды, 
которые никакое значение не вычисляют, но меняют значения атрибутов класса, 
меняют состояние класса (возможно, на основе своих аргументов). 
Для команд требуются постусловия.